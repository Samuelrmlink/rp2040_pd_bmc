;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

.program differential_manchester_tx
.side_set 1 opt

; Transmit one bit every 16 cycles. In each bit period:
; - A '0' is encoded as a transition at the start of the bit period
; - A '1' is encoded as a transition at the start *and* in the middle
;
; Side-set bit 0 must be mapped to the data output pin.
; Autopull must be enabled.
safe_state:
    nop                 side 1 [7]
    nop                 [7]
    nop                 side 0
reset_delay:
    nop                 [3]
public start:
initial_high:
    mov pins, y
    out x, 1
    out y, 1         side 1 [4]
    jmp !x high_0
high_1:
    nop
    jmp initial_high    side 0 [6]
high_0:
    jmp initial_low     [7]             ; effectively 'nop' (since it drops through)

initial_low:
    nop
    jmp !y reset_delay   side 0 [3]
    out x, 1
    out y, 1
    jmp !x low_0
low_1:
    nop
    jmp initial_low     side 1 [6]
low_0:
    jmp !y safe_state   [6]
    jmp initial_high

% c-sdk {
/*
 *  Original Author: Raspberry Pi (Trading) Ltd.
 *  Original Example: differential_manchester.pio
 *  Modified by: Samuel Hedrick
 *
 *  This function takes the following pins:
 *  base_pin        : TX_HIGH - encodes the actual clock/data   - Sideset
 *  base_pin + 1    : TX_LOW - asserts control of CC line       - OUT instruction
 *
 *  TX_HIGH encodes both the clock and data - it drives an N-channel mosfet that pulls the CC line high
 *  TX_LOW drives the CC pin low - allowing the TX_HIGH pin output to drive it high again
 *
 *  Expected PIO operation: 
 *      TX FIFO is set to autopull to OSR (Output shift register)
 *      2 bits are consumed from OSR each cycle
 *          Bit0 controls the raw BMC data encoded into the clock signal
 *          Bit1 must be set to '1' during transmit - and then back to '0' after the EOP symbol has been transmitted
 *
 */
static inline void differential_manchester_tx_program_init(PIO pio, uint sm, uint offset, uint base_pin, float div) {
    pio_sm_set_pins_with_mask(pio, sm, 0, 3u << base_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 2, true);
    pio_gpio_init(pio, base_pin);
    pio_gpio_init(pio, base_pin + 1);

    pio_sm_config c = differential_manchester_tx_program_get_default_config(offset);
    sm_config_set_out_pins(&c, base_pin + 1, 1);
    sm_config_set_sideset_pins(&c, base_pin);
    sm_config_set_out_shift(&c, true, true, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset + differential_manchester_tx_offset_start, &c);

    // Execute a blocking pull so that we maintain the initial line state until data is available
    pio_sm_exec(pio, sm, pio_encode_pull(false, true));
    pio_sm_set_enabled(pio, sm, true);
}
%}
.program differential_manchester_rx

; Assumes line is idle low
; One bit is 16 cycles. In each bit period:
; - A '0' is encoded as a transition at time 0
; - A '1' is encoded as a transition at time 0 and a transition at time T/2
;
; The IN mapping and the JMP pin select must both be mapped to the GPIO used for
; RX data. Autopush must be enabled.

public start:
initial_high:           ; Find rising edge at start of bit period
    wait 1 pin, 0  [10] ; Delay to eye of second half-period (i.e 3/4 of way
    irq nowait 0
    jmp pin high_0      ; through bit) and branch on RX pin high/low.
high_1:
    in x, 1             ; Second transition detected (a `1` data symbol)
    jmp initial_high
high_0:
    in y, 1 [1]         ; Line still high, no centre transition (data is `0`)
    ; Fall-through

.wrap_target
initial_low:            ; Find falling edge at start of bit period
    wait 0 pin, 0 [10]  ; Delay to eye of second half-period
    irq nowait 0
    jmp pin low_1
low_0:
    in y, 1             ; Line still low, no centre transition (data is `0`)
    jmp initial_high
low_1:                  ; Second transition detected (data is `1`)
    in x, 1 [1]
.wrap

% c-sdk {
static inline void differential_manchester_rx_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_gpio_init(pio, pin);

    pio_sm_config c = differential_manchester_rx_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT
    sm_config_set_jmp_pin(&c, pin); // for JMP
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset, &c);

    // X and Y are set to 0 and 1, to conveniently emit these to ISR/FIFO.
    pio_sm_exec(pio, sm, pio_encode_set(pio_x, 1));
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, 0));
    pio_sm_set_enabled(pio, sm, true);
}
%}
